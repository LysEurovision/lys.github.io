<script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js" integrity="sha512-3j3VU6WC5rPQB4Ld1jnLV7Kd5xr+cq9avvhwqzbH/taCRNURoeEpoPBK9pDyeukwSxwRPJ8fDgvYXd6SkaZ2TA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
    const FLAG_EMOJIS = {
        "Andorra": "\uD83C\uDDE6\uD83C\uDDE9",
        "Albania": "\uD83C\uDDE6\uD83C\uDDF1",
        "Armenia": "\uD83C\uDDE6\uD83C\uDDF2",
        "Austria": "\uD83C\uDDE6\uD83C\uDDF9",
        "Australia": "\uD83C\uDDE6\uD83C\uDDFA",
        "Azerbaijan": " \uD83C\uDDE6\uD83C\uDDFF",
        "Bosnia and Herzegovina": "\uD83C\uDDE7\uD83C\uDDE6",
        "Belgium": "\uD83C\uDDE7\uD83C\uDDEA",
        "Bulgaria": "\uD83C\uDDE7\uD83C\uDDEC",
        "Belarus": "\uD83C\uDDE7\uD83C\uDDFE",
        "Switzerland": "\uD83C\uDDE8\uD83C\uDDED",
        "Cyprus": "\uD83C\uDDE8\uD83C\uDDFE",
        "Czech Republic": "\uD83C\uDDE8\uD83C\uDDFF",
        "Germany": "\uD83C\uDDE9\uD83C\uDDEA",
        "Denmark": "\uD83C\uDDE9\uD83C\uDDF0",
        "Estonia": "\uD83C\uDDEA\uD83C\uDDEA",
        "Spain": "\uD83C\uDDEA\uD83C\uDDF8",
        "Finland": "\uD83C\uDDEB\uD83C\uDDEE",
        "France": "\uD83C\uDDEB\uD83C\uDDF7",
        "United Kingdom": "\uD83C\uDDEC\uD83C\uDDE7",
        "Georgia": "\uD83C\uDDEC\uD83C\uDDEA",
        "Greece": "\uD83C\uDDEC\uD83C\uDDF7",
        "Croatia": "\uD83C\uDDED\uD83C\uDDF7",
        "Hungary": "\uD83C\uDDED\uD83C\uDDFA",
        "Ireland": "\uD83C\uDDEE\uD83C\uDDEA",
        "Israel": "\uD83C\uDDEE\uD83C\uDDF1",
        "Iceland": "\uD83C\uDDEE\uD83C\uDDF8",
        "Italy": "\uD83C\uDDEE\uD83C\uDDF9",
        "Kazakhstan": "\uD83C\uDDF0\uD83C\uDDFF",
        "Lebanon": "\uD83C\uDDF1\uD83C\uDDE7",
        "Liechtenstein": "\uD83C\uDDF1\uD83C\uDDEE",
        "Lithuania": "\uD83C\uDDF1\uD83C\uDDF9",
        "Luxembourg": "\uD83C\uDDF1\uD83C\uDDFA",
        "Latvia": "\uD83C\uDDF1\uD83C\uDDFB",
        "Morocco": "\uD83C\uDDF2\uD83C\uDDE6",
        "Monaco": "\uD83C\uDDF2\uD83C\uDDE8",
        "Moldova": "\uD83C\uDDF2\uD83C\uDDE9",
        "Montenegro": "\uD83C\uDDF2\uD83C\uDDEA",
        "Malta": "\uD83C\uDDF2\uD83C\uDDF9",
        "Netherlands": "\uD83C\uDDF3\uD83C\uDDF1",
        "North Macedonia": "\uD83C\uDDF2\uD83C\uDDF0",
        "Norway": "\uD83C\uDDF3\uD83C\uDDF4",
        "Poland": "\uD83C\uDDF5\uD83C\uDDF1",
        "Portugal": "\uD83C\uDDF5\uD83C\uDDF9",
        "Romania": "\uD83C\uDDF7\uD83C\uDDF4",
        "Serbia": "\uD83C\uDDF7\uD83C\uDDF8",
        "Russia": "\uD83C\uDDF7\uD83C\uDDFA",
        "Sweden": "\uD83C\uDDF8\uD83C\uDDEA",
        "Slovenia": "\uD83C\uDDF8\uD83C\uDDEE",
        "Slovakia": "\uD83C\uDDF8\uD83C\uDDF0",
        "San Marino": "\uD83C\uDDF8\uD83C\uDDF2",
        "Turkey": "\uD83C\uDDF9\uD83C\uDDF7",
        "Ukraine": "\uD83C\uDDFA\uD83C\uDDE6",
        "Kosovo": "\uD83C\uDDFD\uD83C\uDDF0"
    }
    const ONE_DAY = 24 * 60 * 60 * 1000;
    const TODAY = new Date("February 19 2022");
    let PAST_EVENTS = [];
    let FUTURE_EVENTS = [];
    const CHART_MAX_HOURS_SCOPE = 6;

    function initSettings() {
        if (localStorage.getItem('dark_theme') === undefined) {
            localStorage.setItem('dark_theme', "enabled");
        } else if (localStorage.getItem('dark_theme') == "disabled") {
            $("body").removeClass("dark-mode").addClass("light-mode");
            $("#dark-mode-toggle").prop("checked", false);
        }

        if (localStorage.getItem('display_legend') === undefined) {
            localStorage.setItem('display_legend', "yes");
        } else if (localStorage.getItem('display_legend') == "no") {
            $(".legend ul").css("display", "none");
            $("#legend-toggle").find(".material-icons").html("expand_more");
        }
    }

    function addMonthLabel(month, isFuture) {
        if (isFuture) {
            $("#calendar").append(`<div class="month-label">${month}</div>`);
        } else {
            $("#calendar").prepend(`<div class="month-label">${month}</div>`);
        }
    }

    function addEvent(event, date, isFuture) {
        const isTimePlaceholder = event['dateTimeCet'].substring(11, 16) == "00:00";
        let isEventMoreThan7DaysAway = true;
        const watchLinks = event['watchLinks']
            .filter(link => isFuture ? link['live'] : link['replayable']) // if the event is in the future, show only the links that can be viewed live; if it's in the past, show only the links that can be viewed on replay
            .sort((l1, l2) => l1['comment'] == 'Recommended link' ? -1 : 1);
        let displayChannel = "";
        if (watchLinks && watchLinks.length > 0 && 'channel' in watchLinks[0]) {
            displayChannel = watchLinks[0]['channel'];
        } else if (event['watchLinks'] && event['watchLinks'].length > 0 && 'channel' in event['watchLinks'][0]) {
            displayChannel = event['watchLinks'][0]['channel'];
        }
        const isGeoblocked = event["watchLinks"].length == 1 && event['watchLinks'][0]['geoblocked'] == true;
        const isAccountRequired = event["watchLinks"].length == 1 && event['watchLinks'][0]['accountRequired'] == true;

        let delta = 0;
        let hours = 0;
        let minutes = 0;
        if (!isTimePlaceholder) {
            isEventMoreThan7DaysAway = Math.round((date - TODAY) / ONE_DAY) > 7;
            if (!isEventMoreThan7DaysAway) {
                delta = Math.abs(new Date(event['dateTimeCet']).getTime() - new Date(event['endDateTimeCet']).getTime()) / 1000;
                hours = Math.floor(delta / 3600) % 24;
                delta -= hours * 3600;
                minutes = Math.floor(delta / 60) % 60;
                if (minutes < 10) {
                    minutes = "0" + minutes;
                }
            }
        }

        let htmlString = `
            <div class="card ${isFuture ? '' : 'past-event'}">
                <div class="card-container">
                    <div class="date">
                        <div class="date-container">
                            <div class="day">${date.toLocaleString('default', { day: '2-digit' })}</div>
                            <div class="month">${date.toLocaleString('en-GB', { month: 'short' })}</div>
                            ${isTimePlaceholder ? '' : '<div class="time">' + date.toLocaleString('en-GB', {hour: '2-digit', minute: '2-digit'}) + ' CET</div>'}
                            ${isTimePlaceholder || isEventMoreThan7DaysAway ? '' : '<div class="duration"><i class="material-icons">hourglass_empty</i><span class="string">' + hours + 'h' + minutes + '</span></div>'}
                        </div>
                    </div>
                    <div class="details">
                        <div class="vertical-container">
                            <div class="condensable">
                                <div class="country">${event['country'] in FLAG_EMOJIS ? FLAG_EMOJIS[event['country']] + ' ' : ''}${event['country']}</div>
                                <div class="show-name">${event['name']}</div>
                                <div class="show-stage">${event['stage']}</div>
                                <div class="labels">
                                    ${displayChannel != "" ? '<div class="label">' + displayChannel + '</div>' : ''}
                                    ${isAccountRequired ? '<div class="label">Account required</div>' : ''}
                                    ${isGeoblocked ? '<div class="label red">Geoblocked</div>' : ''}
                                </div>
                            </div>
                        </div>
                    </div>
                    <a href="#!" class="watch-link-action ${watchLinks.length == 0 ? 'no-link' : ''} ${isGeoblocked ? 'geoblocked' : ''}">
                        <i class="material-icons" original-icon="${watchLinks.length > 0 ? 'play_arrow' : 'play_disabled'}">${watchLinks.length > 0 ? 'play_arrow' : 'play_disabled'}</i>
                    </a>
                </div>
                <div class="watch-links-wrapper" style="display: none;">
        `
        watchLinks.forEach((link, i) => {
                const comment = link['comment'] == "Recommended link" ? 'recommended' : link['comment'];
                const geoblocked = link['geoblocked'];
                htmlString += `
                    <div class="watch-link ${geoblocked ? 'geoblocked' : ''}">
                        <a href="${(!link['link'].startsWith('http') ? 'http://' : '') + link['link']}" class="main-link">
                            <span class="title">Link #${i+1} <span class="comment">${!geoblocked && comment ? '(' + comment + ')' : ''}</span></span>
                            <span class="link">${link['link'].replace('https://', '').replace('http://', '').replace('www.', '').split('/', 2)[0]}</span>
                            ${geoblocked ? '<i class="material-icons">public_off</i>' : ''}
                            ${link['accountRequired'] ? '<i class="material-icons">person</i>' : ''}
                            ${link['castable'] ? '<i class="material-icons">cast</i>' : ''}
                            ${link['replayable'] ? '<i class="material-icons">replay</i>' : ''}
                        </a>
                        ${link['accountRequired'] ? '<a href="./help.html#account-' + event['country'] + '" class="create-account-link" style="">Create account</a>' : ''}
                    </div>
                `;
        });

        if (watchLinks.length == 0) {
            htmlString += `
                <div class="watch-link no-link">
                    <span class="title">No watch link available (${isFuture ? 'yet' : 'anymore'}?) :(</span>
                </div>
            `;
        }

        htmlString += `
                </div>
            </div>
        `;
        if (isFuture) {
            $("#calendar").append(htmlString);
        } else {
            $("#calendar").prepend(htmlString);
        }
    }

    function enableWatchLinks(isFuture) {
        const selector = (!isFuture ? '.past-event ' : '') + 'a.watch-link-action';
        $(selector).click(function() {
            const areLinksHidden = $(this).parent().siblings(".watch-links-wrapper").css("display") == "none";
            if (areLinksHidden) {
                $(this).parent().siblings(".watch-links-wrapper").css("display", "block");
                $(this).find(".material-icons").html("expand_less");
            } else {
                $(this).parent().siblings(".watch-links-wrapper").css("display", "none");
                $(this).find(".material-icons").html($(this).find(".material-icons").attr("original-icon"));
            }
        });
    }


    // TODO set chart-separator border width based on wrapper's scope
    // TODO show chart only if > 2 events
    // TODO add toggle to display chart or not... display the first few line with a "show full (insert accurate name here)" button?
    // TODO outlasting class on `.show`s running over scope
    // TODO twitter integration

    function displayEventsChart(todaysEvents) {
        const firstEventStart = todaysEvents[0]['dateTimeCet'];
        const firstEventStartMs = new Date(firstEventStart).getTime();
        const eventEnds = todaysEvents.map(event => event['endDateTimeCet']);
        eventEnds.sort();
        const scopeInMinutes = Math.abs(new Date(eventEnds[eventEnds.length - 1]).getTime() - firstEventStartMs) / 1000 / 60;
        const todaysCountries = Array.from(new Set(todaysEvents.map(event => event['country'])));
        $("#next-events-chart").css("--scope", scopeInMinutes).css("height", (40 + 40 * todaysCountries.length) + "px");
        $("#chart-overlay-title").html("It's a Super " + TODAY.toLocaleString('en-GB', {weekday: 'long'}) + "!")
        $("#next-events-chart-container").css("display", "block");

        // draw time axis
        const hours = [];
        if (firstEventStart.substring(14, 16) != "00") {
            // round to next full hour and start chart axis labelling at that time
            const p = 60 * 60 * 1000; // milliseconds in an hour
            hours.push(parseInt(new Date(Math.ceil(firstEventStartMs / p ) * p).toLocaleString('en-GB', {hour: '2-digit'})))
        } else {
            hours.push(parseInt(firstEventStart.substring(11, 13)));
        }
        //const maxHourOnAxis = Math.min(parseInt(eventEnds[eventEnds.length - 1].substring(11, 13)), CHART_MAX_HOURS_SCOPE);
        let maxHourOnAxis = new Date(Math.min(new Date(eventEnds[eventEnds.length - 1]).getTime(), new Date(firstEventStartMs + CHART_MAX_HOURS_SCOPE * 60 * 60 * 1000).getTime())).getHours();
        if (maxHourOnAxis < 12) {
            maxHourOnAxis += 24;
        }
        //let maxHourOnAxis = 25;
        let itHours = 0;
        for (itHours = hours[0] + 1; itHours < maxHourOnAxis; itHours++) {
            //hours.push(itHours % 24);
            hours.push(itHours);
        }
        // if last event doesn't end at a full hour, add the last full hours label
        if (eventEnds[eventEnds.length - 1].substring(14, 16) != "00") {
            //hours.push(itHours % 24);
            hours.push(itHours);
        }

        //const offset = parseInt(firstEventStart.substring(14, 16)) / 5;
        const offset = ((60 - parseInt(firstEventStart.substring(14, 16))) % 60) / 5;
        const chartStartHour = hours[0];
        hours.forEach((hour) => {
            // centerPositionOnGrid = amount of hours since the first hours displayed on the axis of the
            // chart (hour - chartStartHour) * the number of columns used on the grid to represent an hour
            // (12, for a scale of 5 minutes) + an offset of columns corresponding to the start of the chart
            // (the difference in minutes between the start time of the first event and the current hour)
            const centerPositionOnGrid = (hour - chartStartHour) * 12 + offset;
            console.log(centerPositionOnGrid);
            const gridColumnForLabel = centerPositionOnGrid < 4 ? '1 / 8' : (centerPositionOnGrid - 3) + ' / ' + (centerPositionOnGrid + 4);
            //const labelHtmlString = `<div class="chart-label" style="grid-column: ${centerPositionOnGrid - 3} / ${centerPositionOnGrid + 4}">${(hour < 10 ? '0' : '') + hour}:00 CET</div>`;
            const labelHtmlString = `<div class="chart-label" style="grid-column: ${gridColumnForLabel}"><span class="chart-label-text">${((hour % 24) < 10 ? '0' : '') + (hour % 24)}:00 CET</span></div>`;
            const separatorHtmlString = `<div class="chart-separator" style="grid-column: ${centerPositionOnGrid}; --height: ${todaysCountries.length}"><div class="chart-separator-filling"></div></div>`;
            $("#next-events-chart").append(labelHtmlString);
            $("#next-events-chart").append(separatorHtmlString);
        });

        // draw events

        const todaysEventsByCountry = todaysEvents.reduce((todaysEventsByCountry, event) => {
            const country = (todaysEventsByCountry[event['country']] || []);
            country.push(event);
            todaysEventsByCountry[event['country']] = country;
            return todaysEventsByCountry;
        }, {});

        todaysCountries.forEach((country, index) => {
            const events = todaysEventsByCountry[country];
            const line = index + 2;
            events.forEach((event) => {
                const start = Math.abs(new Date(event['dateTimeCet']).getTime() - firstEventStartMs) / 1000 / 60;
                const duration = Math.abs(new Date(event['endDateTimeCet']).getTime() - new Date(event['dateTimeCet']).getTime()) / 1000 / 60;
                // class = outlasting
                const htmlString = `
                    <div class="show" style="--start: ${start}; --duration: ${duration}; --line: ${line}">
                        <a href="#!">${event['country'] in FLAG_EMOJIS ? FLAG_EMOJIS[event['country']] : ''}</a>
                    </div>
                `;
                $("#next-events-chart").append(htmlString);
            });
        });

        $("#show-schedule").click(function() {
            $("#next-events-chart-container > .chart-overlay").css("display", "none");
            $("#schedule-header").css("display", "flex");
            $("#next-events-chart-container").css("height", "fit-content").css("overflow", "visible").css("margin-bottom", "0");
            $("#next-events-chart").removeClass("chart-hidden");
            // TODO remove blur
        });
    }

    $(function() {
        initSettings();
        $("#dark-mode-toggle").change(function() {
            if ($(this).is(":checked")) {
                $("body").removeClass("light-mode").addClass("dark-mode");
                localStorage.setItem('dark_theme', "enabled");
            } else {
                $("body").removeClass("dark-mode").addClass("light-mode");
                localStorage.setItem('dark_theme', "disabled");
            }
        });

        $("#legend-toggle").click(function() {
            const isLegendHidden = $(this).parent().siblings("ul").css("display") == "none";
            if (isLegendHidden) {
                $(this).parent().siblings("ul").css("display", "block");
                $(this).find(".material-icons").html("expand_less");
                localStorage.setItem('display_legend', "yes");
            } else {
                $(this).parent().siblings("ul").css("display", "none");
                $(this).find(".material-icons").html("expand_more");
                localStorage.setItem('display_legend', "no");
            }
        });

        $.getJSON("https://raw.githubusercontent.com/LysEurovision/lyseurovision.github.io/main/lys_dump.json", function(data, status) {
            const todayAsStr = TODAY.toLocaleString('se-SE', { timeZone: 'CET'}).replace(' ', 'T');

            PAST_EVENTS = data.filter(event => {
                return event['endDateTimeCet'] < todayAsStr;
            }).sort((e1, e2) => e1['dateTimeCet'] == e2['dateTimeCet'] ? ('' + e1['country']).localeCompare('' + e2['country']) : ('' + e1['dateTimeCet']).localeCompare('' + e2['dateTimeCet']));

            FUTURE_EVENTS = data.filter(event => {
                return event['endDateTimeCet'] >= todayAsStr;
            });

            TODAY_EVENTS = FUTURE_EVENTS.filter(event => {
                return event['dateTimeCet'].substring(0, 10) == todayAsStr.substring(0, 10) && event['dateTimeCet'].substring(11, 16) >= "17:00";
                //return event['country'] == 'Slovenia' && event['dateTimeCet'].substring(0, 10) == todayAsStr.substring(0, 10) && event['dateTimeCet'].substring(11, 16) >= "17:00";
            });

            if (TODAY_EVENTS.length > 2) {
                displayEventsChart(TODAY_EVENTS);
            }

            if (FUTURE_EVENTS.length == 0) {
                if (PAST_EVENTS.length == 0) {
                    $("#no-event .season-start").css("display", "inline");
                    $("#no-event .season-end").css("display", "none");
                } else {
                    $("#no-event .season-start").css("display", "none");
                    $("#no-event .season-end").css("display", "inline");
                }
                $("#no-event").css("display", "block");
            }

            let lastMonth = "";
            FUTURE_EVENTS.forEach((event) => {
                const date = new Date(event['dateTimeCet']);
                const month = date.toLocaleString('en-GB', { month: 'long' });
                if (month != lastMonth) {
                    lastMonth = month;
                    addMonthLabel(month, true);
                }
                addEvent(event, date, true);
            });
            enableWatchLinks(true);

            if (PAST_EVENTS.length > 0) {
                $("#show-past-events").css("display", "flex");
            }
        });

        $("#show-past-events").click(function() {
            $("#no-event").css("display", "none");
            $("#show-past-events").css("display", "none");
            $(".month-label:first").remove();
            let lastMonth = new Date(FUTURE_EVENTS.length > 0 ? FUTURE_EVENTS[0]['dateTimeCet'] : PAST_EVENTS[PAST_EVENTS.length - 1]['dateTimeCet']).toLocaleString('en-GB', { month: 'long' });
            for (let i=PAST_EVENTS.length - 1; i>=0; i--) {
                const event = PAST_EVENTS[i];
                const date = new Date(event['dateTimeCet']);
                const month = date.toLocaleString('en-GB', { month: 'long' });
                if (month != lastMonth) {
                    addMonthLabel(lastMonth, false);
                    lastMonth = month;
                }
                addEvent(event, date, false);
            }
            addMonthLabel(new Date(PAST_EVENTS[0]['dateTimeCet']).toLocaleString('en-GB', { month: 'long' }), false);
            enableWatchLinks(false);
        });
    })
</script>
<meta content="width=device-width, initial-scale=1" name="viewport" />
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="style.alpha.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/icon?family=Material+Icons|Material+Icons+Outlined" rel="stylesheet">
<title>Lys</title>
<body class="dark-mode">
    <div class="nav">
        <a href="./help.html">Help</a> ·
        <a href="https://bsky.app/profile/eurovisionlys.bsky.social">Bluesky</a> ·
        <a href="https://www.threads.net/@eurovisionlys">Threads</a> ·
        <a href="https://x.com/eurovisionlys/">Twitter</a>
    </div>
    <div class="header">
        <div class="logo">Lys</div>
        <div class="toggle">
            <label class="pure-material-switch">
                <input type="checkbox" id="dark-mode-toggle" checked>
                <span><i class="material-icons-outlined">dark_mode</i></span>
            </label>
        </div>
    </div>

    <div id="schedule-header" style="display: none">
        <div class="content-title" style="flex: 1;">Schedule</div>
        <a href="#!" style="display: flex;align-items: center; text-decoration: none;">Hide<i class="material-icons">expand_less</i></a>
    </div>

    <div id="next-events-chart-container" class="chart-container">
        <div class="chart-overlay">
            <div id="chart-overlay-title" style="font-size: 20px;font-weight: 1000;"></div>
            <div style="font-size: 13px;margin-top: 0.5em;">See tonight's planning at a glance by showing the schedule</div>
            <a href="#!" id="show-schedule" class="button">
                <i class="material-icons-outlined">open_in_full</i>
                <span>Show schedule</span>
            </a>
        </div>
        <div id="next-events-chart" class="chart-wrapper chart-hidden">
        </div>
    </div>

    <div class="content-title" style="margin-top: 0.5em">Calendar</div>

    <div class="legend">
        <div class="title"><a href="#!" id="legend-toggle">Legend <i class="material-icons">expand_less</i></a></div>
        <ul>
            <li><i class="material-icons">public_off</i> Geoblocked</li>
            <li><i class="material-icons">person</i> Account required</li>
            <li><i class="material-icons">replay</i> Replayable</li>
            <li><i class="material-icons">cast</i> Castable</li>
        </ul>
    </div>

    <a href="#!" id="show-past-events" class="button" style="display: none">
        <i class="material-icons-outlined">arrow_upward</i>
        <span>Show past</span>
    </a>
    <div id="calendar">
    </div>
    <div id="no-event">
        <div id="no-event-title">No show <span class="season-start">yet</span><span class="season-end">left</span>! :(</div>
        <div id="no-event-description">There is no scheduled Eurovision national final show <span class="season-start">yet</span><span class="season-end">left</span> this season. Come back later<span class="season-end"> (or browse this season's past shows by clicking the "Show past" button above)</span>!</div>
    </div>
</body>